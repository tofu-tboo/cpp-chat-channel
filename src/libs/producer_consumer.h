#ifndef __PRODUCER_CONSUMER_H__
#define __PRODUCER_CONSUMER_H__

#include <queue>
#include <mutex>
#include <condition_variable>

/* FULLY GENERATED BY AI */

/*
Thread-safe Producer-Consumer Queue
Integrates synchronization logic (mutex, condition_variable) into a single class.
*/
template <typename T>
class ProducerConsumerQueue {
private:
    std::queue<T> queue_;
    mutable std::mutex mutex_;
    std::condition_variable cond_;
    bool stopped_ = false;

public:
    ProducerConsumerQueue() = default;
    
    // 복사 방지 (동기화 객체는 복사 불가)
    ProducerConsumerQueue(const ProducerConsumerQueue&) = delete;
    ProducerConsumerQueue& operator=(const ProducerConsumerQueue&) = delete;

    ~ProducerConsumerQueue();

    // Producer: 데이터 추가
    void push(T item);

    // Consumer: 데이터 꺼내기 (Blocking)
    // 큐에 데이터가 들어올 때까지 대기합니다.
    // stop()이 호출되어 종료되거나 큐가 비어있으면 false를 반환합니다.
    bool wait_and_pop(T& out_item);

    // Consumer: 데이터 꺼내기 (Non-blocking)
    // 큐가 비어있으면 즉시 false를 반환합니다.
    bool try_pop(T& out_item);

    // Consumer: 모든 데이터 꺼내기 (Batch Processing)
    // 락을 한 번만 걸고 큐의 모든 내용을 가져옵니다. (Swap 방식)
    std::queue<T> pop_all();

    // 상태 확인
    bool empty() const;

    size_t size() const;

    // 대기 중인 모든 Consumer를 깨우고 종료 상태로 전환
    void stop();
};

#include "producer_consumer.tpp"
#endif