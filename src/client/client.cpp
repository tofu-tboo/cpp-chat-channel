#include <arpa/inet.h>
#include <netdb.h>
#include <poll.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>

#include <cstring>
#include <queue>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <atomic>
#include <chrono>
#include <iostream>
#include <string>

#include <jansson.h>

#include "../libs/util.h"

// Only for tests, totally generated by AI

static int connect_tcp(const char* host, const char* port) {
    addrinfo hints{}, *res = nullptr;
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;

    int status = getaddrinfo(host, port, &hints, &res);
    if (status != 0 || !res) {
        ERROR("getaddrinfo failed: %s", gai_strerror(status));
        return -1;
    }

    int fd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
    if (fd == -1) {
        ERROR("socket() failed");
        freeaddrinfo(res);
        return -1;
    }

    if (connect(fd, res->ai_addr, res->ai_addrlen) == -1) {
        ERROR("connect() failed");
        close(fd);
        freeaddrinfo(res);
        return -1;
    }

    freeaddrinfo(res);
    return fd;
}

static bool send_frame(int fd, const std::string& payload) {
    uint32_t len = static_cast<uint32_t>(payload.size());
    char header[5];
    snprintf(header, sizeof(header), "%04x", len);

    ssize_t n = send(fd, header, 4, 0);
    if (n != 4) return false;

    size_t sent = 0;
    while (sent < payload.size()) {
        n = send(fd, payload.data() + sent, payload.size() - sent, 0);
        if (n <= 0) return false;
        sent += static_cast<size_t>(n);
    }
    return true;
}

static void display_message(const std::string& payload, const std::string& self_user) {
    json_error_t err;
    json_t* obj = json_loadb(payload.data(), payload.size(), 0, &err);
    if (!obj || !json_is_object(obj)) {
        std::cout << "[recv] " << payload << std::endl;
        if (obj) json_decref(obj);
        return;
    }

    const char* user = json_string_value(json_object_get(obj, "user_name"));
    const char* text = nullptr;
    json_t* payload_obj = json_object_get(obj, "payload");
    if (json_is_object(payload_obj)) {
        text = json_string_value(json_object_get(payload_obj, "text"));
    }

    bool is_self = (user && self_user == user);
    std::string indent = is_self ? std::string(40, ' ') : std::string();
    std::cout << indent
              << (is_self ? "(me) " : "")
              << (user ? user : "?") << ": "
              << (text ? text : "") << std::endl;

    json_decref(obj);
}

static bool recv_frames(int fd, std::string& acc, const std::string& self_user) {
    char buf[4096];
    ssize_t n = recv(fd, buf, sizeof(buf), 0);
    if (n <= 0) return false;
    acc.append(buf, n);

    while (acc.size() >= 4) {
        uint32_t len = 0;
        try {
            len = std::stoul(acc.substr(0, 4), nullptr, 16);
        } catch (...) { return false; }

        if (acc.size() < 4 + len) break;
        std::string payload = acc.substr(4, len);
        display_message(payload, self_user);
        acc.erase(0, 4 + len);
    }
    return true;
}

int main(int argc, char* argv[]) {
    const char* host = (argc > 1) ? argv[1] : "127.0.0.1";
    const char* port = (argc > 2) ? argv[2] : "4800";
    const char* user = (argc > 3) ? argv[3] : "client";

    int fd = connect_tcp(host, port);
    if (fd == -1) {
        return 1;
    }
    LOG(_CG_ "connected to %s:%s" _EC_, host, port);

    pollfd pfd{};
    pfd.fd = fd;
    pfd.events = POLLIN;

    std::atomic<bool> stop(false);
    std::queue<std::string> send_queue;
    std::mutex mtx;
    std::condition_variable cv;
    std::string buf;

    auto producer = [&]() {
        pollfd in_fd{};
        in_fd.fd = STDIN_FILENO;
        in_fd.events = POLLIN;
        while (!stop.load()) {
            int r = poll(&in_fd, 1, 200);
            if (r == -1) {
                continue;
            }
            if (r == 0) {
                continue;
            }
            if (in_fd.revents & POLLIN) {
                std::string line;
                if (!std::getline(std::cin, line)) {
                    stop.store(true);
                    cv.notify_all();
                    break;
                }
                if (line.empty()) {
                    continue;
                }
                {
                    std::lock_guard<std::mutex> lock(mtx);
                    send_queue.push(std::move(line));
                }
                cv.notify_one();
            }
        }
    };

    std::thread producer_thread(producer);

    while (!stop.load()) {
        int ready = poll(&pfd, 1, 200);
        if (ready == -1) {
            ERROR("poll failed");
            break;
        }

        if (pfd.revents & (POLLERR | POLLHUP | POLLNVAL)) {
            ERROR("server closed");
            break;
        }
        if (pfd.revents & POLLIN) {
            if (!recv_frames(fd, buf, user)) {
                ERROR("recv failed");
                break;
            }
        }

        // consume queued messages
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait_for(lock, std::chrono::milliseconds(1), [&]() { return stop.load() || !send_queue.empty(); });
        while (!send_queue.empty()) {
            std::string line = std::move(send_queue.front());
            send_queue.pop();
            lock.unlock();

            json_t* obj = json_pack("{ssss{s:s}}",
                                    "type", "message",
                                    "channel_id", "default",
                                    "user_name", user,
                                    "payload", "text", line.c_str());
            if (!obj) {
                ERROR("json_pack failed");
                lock.lock();
                continue;
            }
            char* dumped = json_dumps(obj, JSON_COMPACT);
            if (!dumped) {
                json_decref(obj);
                ERROR("json_dumps failed");
                lock.lock();
                continue;
            }
            std::string payload(dumped);
            free(dumped);
            json_decref(obj);

            if (!send_frame(fd, payload)) {
                ERROR("send failed");
                stop.store(true);
                lock.lock();
                break;
            }

            lock.lock();
        }
    }

    stop.store(true);
    cv.notify_all();
    if (producer_thread.joinable()) {
        producer_thread.join();
    }
    if (fd != -1) close(fd);
    return 0;
}
