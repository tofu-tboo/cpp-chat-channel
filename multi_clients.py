import argparse
import asyncio
import json
import random
import string
import struct
import threading
import queue
import tkinter as tk
from typing import Tuple, List


# Only for tests, totally generated by AI

def make_payload(user: str, text: str, channel: str = "default") -> bytes:
    body = json.dumps(
        {
            "type": "message",
            "channel_id": channel,
            "user_id": user,
            "payload": {"text": text},
        },
        separators=(",", ":"),
    ).encode("utf-8")
    return struct.pack("!I", len(body)) + body


def random_text(min_len: int, max_len: int) -> str:
    length = random.randint(min_len, max_len)
    alphabet = string.ascii_letters + string.digits + " "
    return "".join(random.choice(alphabet) for _ in range(length)).strip()


class ClientWindow:
    def __init__(self, root: tk.Tk, title: str, q: queue.Queue):
        self.q = q
        self.win = tk.Toplevel(root)
        self.win.title(title)
        self.text = tk.Text(self.win, wrap="word", height=20, width=60)
        scroll = tk.Scrollbar(self.win, command=self.text.yview)
        self.text.configure(yscrollcommand=scroll.set)
        self.text.pack(side="left", fill="both", expand=True)
        scroll.pack(side="right", fill="y")

        self.text.tag_configure("self", justify="right", foreground="blue")
        self.text.tag_configure("other", justify="left", foreground="black")
        self.text.tag_configure("status", foreground="gray")
        self.text.insert("end", f"[{title}] window started\n", ("status",))
        self.text.see("end")
        self.poll()

    def poll(self):
        while not self.q.empty():
            kind, *rest = self.q.get()
            if kind == "msg":
                from_user, text, is_self = rest
                tag = "self" if is_self else "other"
                self.text.insert("end", f"{from_user}: {text}\n", (tag,))
            elif kind == "status":
                msg = rest[0]
                self.text.insert("end", f"{msg}\n", ("status",))
            self.text.see("end")
        self.win.after(50, self.poll)


async def handle_client(idx: int, host: str, port: int, delay: Tuple[float, float], text_len: Tuple[int, int], q: queue.Queue):
    user = f"pyclient-{idx}"
    try:
        reader, writer = await asyncio.open_connection(host, port)
    except Exception as e:
        q.put(("status", f"[connect failed] {e}"))
        return

    q.put(("status", f"[{user}] connected"))

    async def sender():
        while True:
            await asyncio.sleep(random.uniform(*delay))
            msg = random_text(*text_len)
            frame = make_payload(user, msg)
            writer.write(frame)
            await writer.drain()

    async def receiver():
        while True:
            header = await reader.readexactly(4)
            (length,) = struct.unpack("!I", header)
            data = await reader.readexactly(length)
            try:
                payload = json.loads(data.decode("utf-8"))
                from_user = payload.get("user_id", "?")
                text = payload.get("payload", {}).get("text", "")
            except Exception:
                from_user = "?"
                text = data.decode(errors="ignore")
            q.put(("msg", from_user, text, from_user == user))

    try:
        await asyncio.gather(sender(), receiver())
    except (asyncio.IncompleteReadError, ConnectionResetError):
        q.put(("status", f"[{user}] connection closed"))
    except Exception as e:
        q.put(("status", f"[{user}] error: {e}"))
    finally:
        try:
            writer.close()
            await writer.wait_closed()
        except Exception:
            pass
        q.put(("status", f"[{user}] shutdown"))


def start_async_clients(args, queues: List[queue.Queue]):
    async def runner():
        tasks = []
        for idx, q in enumerate(queues):
            tasks.append(
                asyncio.create_task(
                    handle_client(
                        idx,
                        args.host,
                        args.port,
                        (args.min_delay, args.max_delay),
                        (args.min_len, args.max_len),
                        q,
                    )
                )
            )
        await asyncio.gather(*tasks)

    asyncio.run(runner())


def main():
    parser = argparse.ArgumentParser(description="Tk GUI for multi async clients")
    parser.add_argument("--host", default="127.0.0.1")
    parser.add_argument("--port", type=int, default=4800)
    parser.add_argument("--clients", type=int, default=5, help="number of concurrent clients/windows")
    parser.add_argument("--min-delay", type=float, default=0.5, help="min seconds between sends")
    parser.add_argument("--max-delay", type=float, default=2.0, help="max seconds between sends")
    parser.add_argument("--min-len", type=int, default=5, help="min message length")
    parser.add_argument("--max-len", type=int, default=40, help="max message length")
    args = parser.parse_args()

    root = tk.Tk()
    root.withdraw()  # hide root, use separate windows

    queues = []
    windows = []
    for i in range(args.clients):
        q = queue.Queue()
        queues.append(q)
        windows.append(ClientWindow(root, f"pyclient-{i}", q))

    t = threading.Thread(target=start_async_clients, args=(args, queues), daemon=True)
    t.start()

    def on_close():
        root.quit()

    root.protocol("WM_DELETE_WINDOW", on_close)
    root.mainloop()


if __name__ == "__main__":
    main()
